"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFollowedByParticiple = isFollowedByParticiple;
exports.isParticiple = isParticiple;
var _lodash = require("lodash");
var _passiveVoiceIrregulars = _interopRequireDefault(require("../../../../languageProcessing/languages/en/config/internal/passiveVoiceIrregulars"));
var _regularParticiplesRegex = require("../../../../languageProcessing/languages/en/config/regularParticiplesRegex");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Checks if a given word is a participle.
 *
 * @param {string} word The word that needs to be checked for whether it is a participle.
 * @returns {boolean} True if the words is a participle, false otherwise.
 */
function isParticiple(word) {
  const participleMatch = word.match(_regularParticiplesRegex.regularParticiplesRegex);
  return !(0, _lodash.isNull)(participleMatch) && participleMatch[0] === word || (0, _lodash.includes)(_passiveVoiceIrregulars.default, word);
}

/**
 * Generates a callback that checks if a non-inclusive phrase is followed by a participle.
 *
 * @param {string[]} words an array of the words that form the text that contains the non inclusive phrase.
 * @param {string[]} nonInclusivePhrase a list of words that are a non inclusive phrase.
 * @returns {function} a callback function that checks if the word after a non inclusive phrase is a participle.
 */
function isFollowedByParticiple(words, nonInclusivePhrase) {
  return index => {
    const followingWordIndex = index + nonInclusivePhrase.length;
    if (followingWordIndex < words.length) {
      const followingWord = words[followingWordIndex];
      return isParticiple(followingWord);
    }
    return false;
  };
}
//# sourceMappingURL=isFollowedByParticiple.js.map