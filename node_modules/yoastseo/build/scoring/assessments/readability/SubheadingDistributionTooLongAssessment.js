"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _i18n = require("@wordpress/i18n");
var _lodash = require("lodash");
var _addMark = _interopRequireDefault(require("../../../markers/addMark"));
var _Mark = _interopRequireDefault(require("../../../values/Mark"));
var _assessment = _interopRequireDefault(require("../assessment"));
var _inRange = require("../../helpers/assessments/inRange");
var _shortlinker = require("../../../helpers/shortlinker");
var _getSubheadings = require("../../../languageProcessing/helpers/html/getSubheadings");
var _getWords = _interopRequireDefault(require("../../../languageProcessing/helpers/word/getWords"));
var _AssessmentResult = _interopRequireDefault(require("../../../values/AssessmentResult"));
var _stripHTMLTags = require("../../../languageProcessing/helpers/sanitize/stripHTMLTags");
var _htmlParser = _interopRequireDefault(require("../../../languageProcessing/helpers/html/htmlParser"));
var _helpers = require("../../../languageProcessing/helpers");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Represents the assessment for calculating the text after each subheading.
 */
class SubheadingsDistributionTooLong extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} config The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      parameters: {
        // The maximum recommended value of the subheading text.
        recommendedMaximumLength: 300,
        slightlyTooMany: 300,
        farTooMany: 350
      },
      countTextIn: (0, _i18n.__)("words", "wordpress-seo"),
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34x"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34y"),
      scores: {
        goodShortTextNoSubheadings: 9,
        goodSubheadings: 9,
        okSubheadings: 6,
        badSubheadings: 3,
        badLongTextNoSubheadings: 2
      },
      applicableIfTextLongerThan: 300,
      shouldNotAppearInShortText: false,
      cornerstoneContent: false
    };
    this.identifier = "subheadingsTooLong";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Checks if the text before the first subheading is long or very long.
   *
   * @param {array} foundSubheadings  An array contains found subheading objects.
   *
   * @returns {{isVeryLong: boolean, isLong: boolean}}    An object containing an information
   *                                                      whether the text before the first subheading is long or very long.
   */
  checkTextBeforeFirstSubheadingLength(foundSubheadings) {
    let textBeforeFirstSubheading = {
      isLong: false,
      isVeryLong: false
    };
    // There is a text if the subheading string of the first object in foundSubheadings is empty and the text is not empty.
    if (foundSubheadings.length > 0 && foundSubheadings[0].subheading === "" && foundSubheadings[0].text !== "") {
      // Retrieve the length of the text before the first subheading.
      const textBeforeFirstSubheadingLength = foundSubheadings[0].countLength;
      textBeforeFirstSubheading = {
        isLong: (0, _inRange.inRangeEndInclusive)(textBeforeFirstSubheadingLength, this._config.parameters.slightlyTooMany, this._config.parameters.farTooMany),
        isVeryLong: textBeforeFirstSubheadingLength > this._config.parameters.farTooMany
      };
    }
    return textBeforeFirstSubheading;
  }

  /**
   * Gets the text length from the paper. Remove unwanted element first before calculating.
   *
   * @param { Paper } paper The Paper object to analyse.
   * @param { Researcher } researcher The researcher to use.
   * @returns {number} The length of the text.
   */
  getTextLength(paper, researcher) {
    // Give specific feedback for cases where the post starts with a long text without subheadings.
    const customCountLength = researcher.getHelper("customCountLength");
    let text = paper.getText();
    text = (0, _htmlParser.default)(text);
    text = (0, _helpers.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);
    return customCountLength ? customCountLength(text) : (0, _getWords.default)(text).length;
  }

  /**
   * Runs the getSubheadingTextLength research and checks scores based on length.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   * @param {Researcher}  researcher  The researcher used for calling research.
   *
   * @returns {AssessmentResult} The assessment result.
   */
  getResult(paper, researcher) {
    this._subheadingTextsLength = researcher.getResearch("getSubheadingTextLengths");
    if (researcher.getConfig("subheadingsTooLong")) {
      this._config = this.getLanguageSpecificConfig(researcher);
    }
    // The configuration to use for Japanese texts.
    const countTextInCharacters = researcher.getConfig("countCharacters");
    if (countTextInCharacters) {
      this._config.countTextIn = (0, _i18n.__)("characters", "wordpress-seo");
    }

    // First check if there is text before the first subheading and check its length.
    // It's important that this check is done before we sort the `this._subheadingTextsLength` array.
    const textBeforeFirstSubheading = this.checkTextBeforeFirstSubheadingLength(this._subheadingTextsLength);
    this._subheadingTextsLength = this._subheadingTextsLength.sort(function (a, b) {
      return b.countLength - a.countLength;
    });
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setIdentifier(this.identifier);
    this._hasSubheadings = this.hasSubheadings(paper);
    this._tooLongTextsNumber = this.getTooLongSubheadingTexts().length;
    this._textLength = this.getTextLength(paper, researcher);
    const calculatedResult = this.calculateResult(textBeforeFirstSubheading);
    calculatedResult.resultTextPlural = calculatedResult.resultTextPlural || "";
    assessmentResult.setScore(calculatedResult.score);
    assessmentResult.setText(calculatedResult.resultText);
    assessmentResult.setHasMarks(calculatedResult.hasMarks);
    return assessmentResult;
  }

  /**
   * Check if there is language-specific config, and if so, overwrite the current config with it.
   *
   * @param {Researcher} researcher The researcher to use.
   *
   * @returns {Object} The config that should be used.
   */
  getLanguageSpecificConfig(researcher) {
    const currentConfig = this._config;
    const languageSpecificConfig = researcher.getConfig("subheadingsTooLong");
    // Check if a language has a default cornerstone configuration.
    if (currentConfig.cornerstoneContent === true && languageSpecificConfig.hasOwnProperty("cornerstoneParameters")) {
      return (0, _lodash.merge)(currentConfig, languageSpecificConfig.cornerstoneParameters);
    }

    // Use the default language-specific config for non-cornerstone condition
    return (0, _lodash.merge)(currentConfig, languageSpecificConfig.defaultParameters);
  }

  /**
   * Checks the applicability of the assessment based on the presence of text, and, if required, text length.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   * @param {Researcher}  researcher  The language-specific or default researcher.
   *
   * @returns {boolean} True when there is text or when text is longer than the specified length and "shouldNotAppearInShortText" is set to true.
   */
  isApplicable(paper, researcher) {
    /**
     * If the assessment should not appear for shorter texts, only set the assessment as applicable if the text meets the minimum required length.
     * Language-specific length requirements and methods of counting text length may apply (e.g. for Japanese, the text should be counted in
     * characters instead of words, which also makes the minimum required length higher).
    **/
    if (this._config.shouldNotAppearInShortText) {
      if (researcher.getConfig("subheadingsTooLong")) {
        this._config = this.getLanguageSpecificConfig(researcher);
      }
      const textLength = this.getTextLength(paper, researcher);

      // Do not use hasEnoughContentForAssessment as it is redundant with textLength > this._config.applicableIfTextLongerThan.
      return textLength > this._config.applicableIfTextLongerThan;
    }
    return this.hasEnoughContentForAssessment(paper);
  }

  /**
   * Checks whether the paper has subheadings.
   *
   * @param {Paper} paper The paper to use for the assessment.
   *
   * @returns {boolean} True when there is at least one subheading.
   */
  hasSubheadings(paper) {
    const subheadings = (0, _getSubheadings.getSubheadings)(paper.getText());
    return subheadings.length > 0;
  }

  /**
   * Creates a marker for each subheading that precedes a text that is too long.
   *
   * @returns {Array} All markers for the current text.
   */
  getMarks() {
    const marks = (0, _lodash.map)(this.getTooLongSubheadingTexts(), function ({
      subheading
    }) {
      subheading = (0, _stripHTMLTags.stripFullTags)(subheading);
      const marked = (0, _addMark.default)(subheading);
      return new _Mark.default({
        original: subheading,
        marked: marked,
        fieldsToMark: ["heading"]
      });
    });
    // This is to ensure that an empty subheading doesn't receive marker tags.
    // If an empty subheading string receives marker tags, clicking on the eye icon next to the assessment will lead to page crashing.
    return (0, _lodash.filter)(marks, mark => mark.getOriginal() !== "");
  }

  /**
   * Counts the number of subheading texts that are too long.
   *
   * @returns {Array} The array containing subheading texts that are too long.
   */
  getTooLongSubheadingTexts() {
    return (0, _lodash.filter)(this._subheadingTextsLength, function (subheading) {
      return subheading.countLength > this._config.parameters.recommendedMaximumLength;
    }.bind(this));
  }

  /**
   * Calculates the score and creates a feedback string based on the subheading texts length.
   *
   * @param {Object} textBeforeFirstSubheading   An object containing information whether the text before the first subheading is long or very long.
   *
   * @returns {Object} The calculated result.
   */
  calculateResult(textBeforeFirstSubheading) {
    if (this._textLength > this._config.applicableIfTextLongerThan) {
      if (this._hasSubheadings) {
        if (textBeforeFirstSubheading.isLong && this._tooLongTextsNumber < 2) {
          /*
           * Orange indicator. Returns this feedback if the text preceding the first subheading is very long
           * and the total number of too long texts is less than 2.
           */
          return {
            score: this._config.scores.okSubheadings,
            hasMarks: false,
            resultText: (0, _i18n.sprintf)(
            /* translators: %1$s and %3$s expand to a link to https://yoa.st/headings, %2$s expands to the link closing tag.
             * %4$s expands to the recommended number of words following a subheading,
             * %5$s expands to the word 'words' or 'characters'.
             */
            (0, _i18n.__)("%1$sSubheading distribution%2$s: The beginning of your text is longer than %4$s %5$s and is not separated by any subheadings. %3$sAdd subheadings to improve readability.%2$s", "wordpress-seo"), this._config.urlTitle, "</a>", this._config.urlCallToAction, this._config.parameters.recommendedMaximumLength, this._config.countTextIn)
          };
        }
        if (textBeforeFirstSubheading.isVeryLong && this._tooLongTextsNumber < 2) {
          /*
           * Red indicator. Returns this feedback if the text preceding the first subheading is very long
           * and the total number of too long texts is less than 2.
           */
          return {
            score: this._config.scores.badSubheadings,
            hasMarks: false,
            resultText: (0, _i18n.sprintf)(
            /* translators: %1$s and %3$s expand to a link to https://yoa.st/headings, %2$s expands to the link closing tag.
             * %4$s expands to the recommended number of words following a subheading,
             * %5$s expands to the word 'words' or 'characters'.
             */
            (0, _i18n.__)("%1$sSubheading distribution%2$s: The beginning of your text is longer than %4$s %5$s and is not separated by any subheadings. %3$sAdd subheadings to improve readability.%2$s", "wordpress-seo"), this._config.urlTitle, "</a>", this._config.urlCallToAction, this._config.parameters.recommendedMaximumLength, this._config.countTextIn)
          };
        }
        const longestSubheadingTextLength = this._subheadingTextsLength[0].countLength;
        if (longestSubheadingTextLength <= this._config.parameters.slightlyTooMany) {
          // Green indicator.
          return {
            score: this._config.scores.goodSubheadings,
            hasMarks: false,
            resultText: (0, _i18n.sprintf)(
            // translators: %1$s expands to a link to https://yoa.st/headings, %2$s expands to the link closing tag.
            (0, _i18n.__)("%1$sSubheading distribution%2$s: Great job!", "wordpress-seo"), this._config.urlTitle, "</a>")
          };
        }
        if ((0, _inRange.inRangeEndInclusive)(longestSubheadingTextLength, this._config.parameters.slightlyTooMany, this._config.parameters.farTooMany)) {
          // Orange indicator.
          return {
            score: this._config.scores.okSubheadings,
            hasMarks: true,
            resultText: (0, _i18n.sprintf)(
            /* translators: %1$s and %5$s expand to a link on yoast.com, %3$d to the number of text sections
            not separated by subheadings, %4$d expands to the recommended number of words or characters following a
            subheading, %6$s expands to the word 'words' or 'characters', %2$s expands to the link closing tag. */
            (0, _i18n._n)("%1$sSubheading distribution%2$s: %3$d section of your text is longer than %4$d %6$s and is not separated by any subheadings. %5$sAdd subheadings to improve readability%2$s.", "%1$sSubheading distribution%2$s: %3$d sections of your text are longer than %4$d %6$s and are not separated by any subheadings. %5$sAdd subheadings to improve readability%2$s.", this._tooLongTextsNumber, "wordpress-seo"), this._config.urlTitle, "</a>", this._tooLongTextsNumber, this._config.parameters.recommendedMaximumLength, this._config.urlCallToAction, this._config.countTextIn)
          };
        }

        // Red indicator.
        return {
          score: this._config.scores.badSubheadings,
          hasMarks: true,
          resultText: (0, _i18n.sprintf)(
          /* translators: %1$s and %5$s expand to a link on yoast.com, %3$d to the number of text sections
          not separated by subheadings, %4$d expands to the recommended number of words or characters following a
          subheading, %6$s expands to the word 'words' or 'characters', %2$s expands to the link closing tag. */
          (0, _i18n._n)("%1$sSubheading distribution%2$s: %3$d section of your text is longer than %4$d %6$s and is not separated by any subheadings. %5$sAdd subheadings to improve readability%2$s.", "%1$sSubheading distribution%2$s: %3$d sections of your text are longer than %4$d %6$s and are not separated by any subheadings. %5$sAdd subheadings to improve readability%2$s.", this._tooLongTextsNumber, "wordpress-seo"), this._config.urlTitle, "</a>", this._tooLongTextsNumber, this._config.parameters.recommendedMaximumLength, this._config.urlCallToAction, this._config.countTextIn)
        };
      }
      // Red indicator, use '2' so we can differentiate in external analysis.
      return {
        score: this._config.scores.badLongTextNoSubheadings,
        hasMarks: false,
        resultText: (0, _i18n.sprintf)( /* translators: %1$s and %3$s expand to a link to https://yoa.st/headings, %2$s expands to the link closing tag. */
        (0, _i18n.__)("%1$sSubheading distribution%2$s: You are not using any subheadings, although your text is rather long. %3$sTry and add some subheadings%2$s.", "wordpress-seo"), this._config.urlTitle, "</a>", this._config.urlCallToAction)
      };
    }
    if (this._hasSubheadings) {
      // Green indicator.
      return {
        score: this._config.scores.goodSubheadings,
        hasMarks: false,
        resultText: (0, _i18n.sprintf)( /* translators: %1$s expands to a link to https://yoa.st/headings, %2$s expands to the link closing tag. */
        (0, _i18n.__)("%1$sSubheading distribution%2$s: Great job!", "wordpress-seo"), this._config.urlTitle, "</a>")
      };
    }
    // Green indicator.
    return {
      score: this._config.scores.goodShortTextNoSubheadings,
      hasMarks: false,
      resultText: (0, _i18n.sprintf)( /* translators: %1$s expands to a link to https://yoa.st/headings, %2$s expands to the link closing tag. */
      (0, _i18n.__)("%1$sSubheading distribution%2$s: You are not using any subheadings, but your text is short enough and probably doesn't need them.", "wordpress-seo"), this._config.urlTitle, "</a>")
    };
  }
}
var _default = exports.default = SubheadingsDistributionTooLong;
//# sourceMappingURL=SubheadingDistributionTooLongAssessment.js.map