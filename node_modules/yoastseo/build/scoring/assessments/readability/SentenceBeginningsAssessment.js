"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _i18n = require("@wordpress/i18n");
var _addMark = _interopRequireDefault(require("../../../markers/addMark"));
var _shortlinker = require("../../../helpers/shortlinker");
var _stripHTMLTags = require("../../../languageProcessing/helpers/sanitize/stripHTMLTags");
var _AssessmentResult = _interopRequireDefault(require("../../../values/AssessmentResult"));
var _Mark = _interopRequireDefault(require("../../../values/Mark"));
var _assessment = _interopRequireDefault(require("../assessment"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const maximumConsecutiveDuplicates = 2;

/**
 * Represents the assessment that checks whether there are three or more consecutive sentences beginning with the same word.
 */
class SentenceBeginningsAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {object} config The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/35f"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/35g")
    };
    this.identifier = "sentenceBeginnings";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Counts and groups the number too often used sentence beginnings and determines the lowest count within that group.
   *
   * @param {array} sentenceBeginnings The array containing the objects containing the beginning words and counts.
   *
   * @returns {object} The object containing the total number of too often used beginnings and the lowest count within those.
   */
  groupSentenceBeginnings(sentenceBeginnings) {
    const tooOften = (0, _lodash.partition)(sentenceBeginnings, function (word) {
      return word.count > maximumConsecutiveDuplicates;
    });
    if (tooOften[0].length === 0) {
      return {
        total: 0
      };
    }
    const sortedCounts = (0, _lodash.sortBy)(tooOften[0], function (word) {
      return word.count;
    });
    return {
      total: tooOften[0].length,
      lowestCount: sortedCounts[0].count
    };
  }

  /**
   * Calculates the score based on sentence beginnings.
   *
   * @param {object} groupedSentenceBeginnings    The object with grouped sentence beginnings.
   *
   * @returns {{score: number, text: string, hasMarks: boolean}} result object with score and text.
   */
  calculateSentenceBeginningsResult(groupedSentenceBeginnings) {
    if (groupedSentenceBeginnings.total > 0) {
      return {
        score: 3,
        hasMarks: true,
        text: (0, _i18n.sprintf)(
        /* translators: %1$s and %5$s expand to a link on yoast.com, %2$s expands to the anchor end tag,
        %3$d expands to the number of consecutive sentences starting with the same word,
        %4$d expands to the number of instances where 3 or more consecutive sentences start with the same word. */
        (0, _i18n._n)("%1$sConsecutive sentences%2$s: The text contains %3$d consecutive sentences starting with the same word. %5$sTry to mix things up%2$s!", "%1$sConsecutive sentences%2$s: The text contains %4$d instances where %3$d or more consecutive sentences start with the same word. %5$sTry to mix things up%2$s!", groupedSentenceBeginnings.total, "wordpress-seo"), this._config.urlTitle, "</a>", groupedSentenceBeginnings.lowestCount, groupedSentenceBeginnings.total, this._config.urlCallToAction)
      };
    }
    return {
      score: 9,
      hasMarks: false,
      text: (0, _i18n.sprintf)( /* translators:  %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sConsecutive sentences%2$s: There is enough variety in your sentences. That's great!", "wordpress-seo"), this._config.urlTitle, "</a>")
    };
  }

  /**
   * Marks all consecutive sentences with the same beginnings.
   *
   * @param {object} paper        The paper to use for the assessment.
   * @param {object} researcher   The researcher used for calling research.
   *
   * @returns {object} All marked sentences.
   */
  getMarks(paper, researcher) {
    let sentenceBeginnings = researcher.getResearch("getSentenceBeginnings");
    sentenceBeginnings = (0, _lodash.filter)(sentenceBeginnings, function (sentenceBeginning) {
      return sentenceBeginning.count > maximumConsecutiveDuplicates;
    });
    const sentences = (0, _lodash.map)(sentenceBeginnings, function (begin) {
      return begin.sentences;
    });
    return (0, _lodash.map)((0, _lodash.flatten)(sentences), function (sentence) {
      sentence = (0, _stripHTMLTags.stripIncompleteTags)(sentence);
      const marked = (0, _addMark.default)(sentence);
      return new _Mark.default({
        original: sentence,
        marked: marked
      });
    });
  }

  /**
   * Scores the repetition of sentence beginnings in consecutive sentences.
   *
   * @param {object} paper        The paper to use for the assessment.
   * @param {object} researcher   The researcher used for calling research.
   *
   * @returns {object} The Assessment result
   */
  getResult(paper, researcher) {
    const sentenceBeginnings = researcher.getResearch("getSentenceBeginnings");
    const groupedSentenceBeginnings = this.groupSentenceBeginnings(sentenceBeginnings);
    const sentenceBeginningsResult = this.calculateSentenceBeginningsResult(groupedSentenceBeginnings);
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setScore(sentenceBeginningsResult.score);
    assessmentResult.setText(sentenceBeginningsResult.text);
    assessmentResult.setHasMarks(sentenceBeginningsResult.hasMarks);
    return assessmentResult;
  }

  /**
   * Checks if the sentence beginnings assessment is applicable to the paper.
   *
   * @param {Object}      paper       The paper to check.
   * @param {Researcher}  researcher  The researcher object.
   *
   * @returns {boolean} Returns true if the language is available and the paper is not empty.
   */
  isApplicable(paper, researcher) {
    return this.hasEnoughContentForAssessment(paper) && researcher.hasResearch("getSentenceBeginnings");
  }
}
exports.default = SentenceBeginningsAssessment;
//# sourceMappingURL=SentenceBeginningsAssessment.js.map