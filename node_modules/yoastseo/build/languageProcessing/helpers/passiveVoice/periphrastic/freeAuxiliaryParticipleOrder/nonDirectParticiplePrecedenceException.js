"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _lodash = require("lodash");
var _createRegexFromArray = _interopRequireDefault(require("../../../regex/createRegexFromArray.js"));
var _getIndicesWithRegex = _interopRequireDefault(require("../getIndicesWithRegex.js"));
var _indices = require("../../../word/indices.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Checks whether there are any exception words in between the auxiliary and participle. If there are, it doesn't return a passive.
 *
 * @param {string} clause 											The clause that contains the participle.
 * @param {string} participle 										The participle in the clause.
 * @param {string[]} auxiliaries 									One or more auxiliaries in the clause.
 * @param {string[]} cannotBeBetweenPassiveAuxiliaryAndParticiple 	The list of words that cannot be between the auxiliary and participle.
 *
 * @returns {boolean} Returns true if a word from the 'cannot be between passive auxiliary and participle' exception list
 * appears anywhere in between the last (closest to participle) auxiliary and the participle.
 */
function _default(clause, participle, auxiliaries, cannotBeBetweenPassiveAuxiliaryAndParticiple) {
  const auxiliariesUnique = (0, _lodash.uniq)(auxiliaries);
  const auxiliaryIndices = (0, _indices.getIndicesByWordListSorted)(auxiliariesUnique, clause);
  const participleIndex = clause.indexOf(participle);
  const nonDirectParticiplePrecendenceExceptionRegex = (0, _createRegexFromArray.default)(cannotBeBetweenPassiveAuxiliaryAndParticiple);

  // This exception is only applicable for passive constructions in which the auxiliary precedes the participle.
  const matches = auxiliaryIndices.filter(auxiliaryIndex => auxiliaryIndex.index < participleIndex);

  // If there are no auxiliaries before the participle, this exception is not applicable.
  if (matches.length === 0) {
    return false;
  }

  // We pick the auxiliary closest to the participle, since that is most likely the one belonging to the participle.
  const participleAuxiliary = matches[matches.length - 1];
  const precedenceExceptionIndices = (0, _getIndicesWithRegex.default)(clause, nonDirectParticiplePrecendenceExceptionRegex);

  // Check whether there are any precendence words between the auxiliary and the participle.
  const remainingPrecedenceExceptionIndices = precedenceExceptionIndices.filter(precedenceExceptionIndex => precedenceExceptionIndex.index > participleAuxiliary.index && precedenceExceptionIndex.index < participleIndex);
  return remainingPrecedenceExceptionIndices.length > 0;
}
//# sourceMappingURL=nonDirectParticiplePrecedenceException.js.map