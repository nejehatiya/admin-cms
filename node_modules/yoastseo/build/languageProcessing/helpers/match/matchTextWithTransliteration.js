"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _lodash = require("lodash");
var _addWordboundary = _interopRequireDefault(require("../word/addWordboundary.js"));
var _stripSpaces = _interopRequireDefault(require("../sanitize/stripSpaces.js"));
var _transliterate = _interopRequireDefault(require("../transliterate/transliterate.js"));
var _transliterateWPstyle = _interopRequireDefault(require("../transliterate/transliterateWPstyle.js"));
var _specialCharacterMappings = require("../transliterate/specialCharacterMappings");
var _index = require("../../index");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Creates a regex from the keyword with included wordboundaries.
 *
 * @param {string} keyword  The keyword to create a regex from.
 * @param {string} language The language used to determine the word boundary.
 *
 * @returns {RegExp} Regular expression of the keyword with word boundaries.
 */
const toRegex = function (keyword, language) {
  keyword = (0, _addWordboundary.default)(keyword, false, "", language);
  return new RegExp(keyword, "ig");
};

/**
 * Matches a string with and without transliteration.
 * @param {string} text The text to match.
 * @param {string} keyword The keyword to match in the text.
 * @param {string} locale The locale used for transliteration.
 * @returns {Array} All matches from the original as the transliterated text and keyword.
 */
function _default(text, keyword, locale) {
  const language = (0, _index.getLanguage)(locale);
  let keywordRegex = toRegex(keyword, language);
  if (language === "tr") {
    const turkishMappings = (0, _specialCharacterMappings.replaceTurkishIsMemoized)(keyword);
    keywordRegex = new RegExp(turkishMappings.map(x => (0, _addWordboundary.default)(x)).join("|"), "ig");
  }
  const matches = text.match(keywordRegex) || [];
  text = text.replace(keywordRegex, "");
  const transliterateKeyword = (0, _transliterate.default)(keyword, locale);
  const transliterateKeywordRegex = toRegex(transliterateKeyword, language);
  const transliterateMatches = text.match(transliterateKeywordRegex) || [];
  let combinedArray = matches.concat(transliterateMatches);
  const transliterateWPKeyword = (0, _transliterateWPstyle.default)(keyword, locale);
  if (!(transliterateWPKeyword === transliterateKeyword)) {
    const transliterateWPKeywordRegex = toRegex(transliterateWPKeyword, language);
    const transliterateWPMatches = text.match(transliterateWPKeywordRegex) || [];
    combinedArray = combinedArray.concat(transliterateWPMatches);
  }
  return (0, _lodash.map)(combinedArray, function (match) {
    return (0, _stripSpaces.default)(match);
  });
}
//# sourceMappingURL=matchTextWithTransliteration.js.map