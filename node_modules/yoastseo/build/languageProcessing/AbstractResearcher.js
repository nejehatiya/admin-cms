"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _invalidType = _interopRequireDefault(require("../errors/invalidType"));
var _missingArgument = _interopRequireDefault(require("../errors/missingArgument"));
var _altTagCount = _interopRequireDefault(require("./researches/altTagCount.js"));
var _countSentencesFromText = _interopRequireDefault(require("./researches/countSentencesFromText.js"));
var _findKeywordInFirstParagraph = _interopRequireDefault(require("./researches/findKeywordInFirstParagraph.js"));
var _findKeyphraseInSEOTitle = _interopRequireDefault(require("./researches/findKeyphraseInSEOTitle"));
var _findTransitionWords = _interopRequireDefault(require("./researches/findTransitionWords"));
var _functionWordsInKeyphrase = _interopRequireDefault(require("./researches/functionWordsInKeyphrase"));
var _getAnchorsWithKeyphrase = _interopRequireDefault(require("./researches/getAnchorsWithKeyphrase"));
var _getFleschReadingScore = _interopRequireDefault(require("./researches/getFleschReadingScore"));
var _getKeywordDensity = _interopRequireWildcard(require("./researches/getKeywordDensity.js"));
var _getLinks = _interopRequireDefault(require("./researches/getLinks.js"));
var _getLinkStatistics = _interopRequireDefault(require("./researches/getLinkStatistics"));
var _getParagraphs = _interopRequireDefault(require("./researches/getParagraphs"));
var _getParagraphLength = _interopRequireDefault(require("./researches/getParagraphLength.js"));
var _getPassiveVoiceResult = _interopRequireDefault(require("./researches/getPassiveVoiceResult"));
var _getProminentWordsForInsights = _interopRequireDefault(require("./researches/getProminentWordsForInsights"));
var _getProminentWordsForInternalLinking = _interopRequireDefault(require("./researches/getProminentWordsForInternalLinking"));
var _getSentenceBeginnings = _interopRequireDefault(require("./researches/getSentenceBeginnings"));
var _getSubheadingTextLengths = _interopRequireDefault(require("./researches/getSubheadingTextLengths.js"));
var _h1s = _interopRequireDefault(require("./researches/h1s"));
var _imageCount = _interopRequireDefault(require("./researches/imageCount.js"));
var _keyphraseLength = _interopRequireDefault(require("./researches/keyphraseLength"));
var _keywordCount = _interopRequireWildcard(require("./researches/keywordCount"));
var _keywordCountInUrl = require("./researches/keywordCountInUrl");
var _matchKeywordInSubheadings = _interopRequireDefault(require("./researches/matchKeywordInSubheadings"));
var _metaDescriptionKeyword = _interopRequireDefault(require("./researches/metaDescriptionKeyword"));
var _metaDescriptionLength = _interopRequireDefault(require("./researches/metaDescriptionLength.js"));
var _getWordForms = _interopRequireDefault(require("./researches/getWordForms"));
var _pageTitleWidth = _interopRequireDefault(require("./researches/pageTitleWidth.js"));
var _readingTime = _interopRequireDefault(require("./researches/readingTime"));
var _sentences = _interopRequireDefault(require("./researches/sentences"));
var _videoCount = _interopRequireDefault(require("./researches/videoCount"));
var _wordCountInText = _interopRequireDefault(require("./researches/wordCountInText.js"));
var _memoizedSentenceTokenizer = _interopRequireDefault(require("./helpers/sentence/memoizedSentenceTokenizer"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// All researches in alphabetical order.

// All helpers.

/**
 * The researcher contains all the researches, helpers, data, and config.
 */
class AbstractResearcher {
  /**
   * Constructor
   * @param {Paper} paper The Paper object that is needed within the researches.
   *
   * @constructor
   */
  constructor(paper) {
    this.paper = paper;

    // We expose the deprecated keywordCountInUrl for backwards compatibility.
    this.defaultResearches = {
      altTagCount: _altTagCount.default,
      countSentencesFromText: _countSentencesFromText.default,
      findKeywordInFirstParagraph: _findKeywordInFirstParagraph.default,
      findKeyphraseInSEOTitle: _findKeyphraseInSEOTitle.default,
      findTransitionWords: _findTransitionWords.default,
      functionWordsInKeyphrase: _functionWordsInKeyphrase.default,
      getAnchorsWithKeyphrase: _getAnchorsWithKeyphrase.default,
      getFleschReadingScore: _getFleschReadingScore.default,
      getKeyphraseCount: _keywordCount.default,
      getKeyphraseDensity: _getKeywordDensity.default,
      getKeywordDensity: _getKeywordDensity.getKeywordDensity,
      getLinks: _getLinks.default,
      getLinkStatistics: _getLinkStatistics.default,
      getParagraphs: _getParagraphs.default,
      getParagraphLength: _getParagraphLength.default,
      getProminentWordsForInsights: _getProminentWordsForInsights.default,
      getProminentWordsForInternalLinking: _getProminentWordsForInternalLinking.default,
      getSentenceBeginnings: _getSentenceBeginnings.default,
      getSubheadingTextLengths: _getSubheadingTextLengths.default,
      h1s: _h1s.default,
      imageCount: _imageCount.default,
      keyphraseLength: _keyphraseLength.default,
      keywordCount: _keywordCount.keywordCount,
      keywordCountInSlug: _keywordCountInUrl.keywordCountInSlug,
      keywordCountInUrl: _keywordCountInUrl.keywordCountInUrl,
      matchKeywordInSubheadings: _matchKeywordInSubheadings.default,
      metaDescriptionKeyword: _metaDescriptionKeyword.default,
      metaDescriptionLength: _metaDescriptionLength.default,
      morphology: _getWordForms.default,
      pageTitleWidth: _pageTitleWidth.default,
      readingTime: _readingTime.default,
      sentences: _sentences.default,
      wordCountInText: _wordCountInText.default,
      videoCount: _videoCount.default,
      getPassiveVoiceResult: _getPassiveVoiceResult.default
    };
    this._data = {};
    this.customResearches = {};
    this.helpers = {
      memoizedTokenizer: _memoizedSentenceTokenizer.default
    };
    this.config = {
      areHyphensWordBoundaries: true
    };
  }

  /**
   * Set the Paper associated with the Researcher.
   *
   * @param {Paper} paper The Paper to use within the Researcher.
   *
   * @throws {InvalidTypeError} Parameter needs to be an instance of the Paper object.
   *
   * @returns {void}
   */
  setPaper(paper) {
    this.paper = paper;
  }

  /**
   * Add a custom research that will be available within the Researcher.
   *
   * @param {string}   name     A name to reference the research by.
   * @param {function} research The function to be added to the Researcher.
   *
   * @throws {MissingArgument}  Research name cannot be empty.
   * @throws {InvalidTypeError} The research requires a valid Function callback.
   *
   * @returns {void}
   */
  addResearch(name, research) {
    if ((0, _lodash.isUndefined)(name) || (0, _lodash.isEmpty)(name)) {
      throw new _missingArgument.default("Research name cannot be empty");
    }
    if (!(research instanceof Function)) {
      throw new _invalidType.default("The research requires a Function callback.");
    }
    this.customResearches[name] = research;
  }

  /**
   * Add research data to the researcher by the research name.
   *
   * @param {string} research The identifier of the research.
   * @param {Object} data     The data object.
   *
   * @returns {void}.
   */
  addResearchData(research, data) {
    this._data[research] = data;
  }

  /**
   * Add a custom helper that will be available within the Researcher.
   *
   * @param {string}   name     A name to reference the helper by.
   * @param {function} helper   The function to be added to the Researcher.
   *
   * @throws {MissingArgument}  Helper name cannot be empty.
   * @throws {InvalidTypeError} The helper requires a valid Function callback.
   *
   * @returns {void}
   */
  addHelper(name, helper) {
    if ((0, _lodash.isUndefined)(name) || (0, _lodash.isEmpty)(name)) {
      throw new _missingArgument.default("Helper name cannot be empty");
    }
    if (!(helper instanceof Function)) {
      throw new _invalidType.default("The research requires a Function callback.");
    }
    this.helpers[name] = helper;
  }

  /**
   * Add a custom configuration that will be available within the Researcher.
   *
   * @param {string}  name     A name to reference the helper by.
   * @param {*}       config   The configuration to be added to the Researcher.
   *
   * @throws {MissingArgument}  Configuration name and the configuration itself cannot be empty.
   *
   * @returns {void}
   */
  addConfig(name, config) {
    if ((0, _lodash.isUndefined)(name) || (0, _lodash.isEmpty)(name)) {
      throw new _missingArgument.default("Failed to add the custom researcher config. Config name cannot be empty.");
    }
    if ((0, _lodash.isUndefined)(config) || (0, _lodash.isEmpty)(config) && config === Object(config)) {
      throw new _missingArgument.default("Failed to add the custom researcher config. Config cannot be empty.");
    }
    this.config[name] = config;
  }

  /**
   * Check whether the research is known by the Researcher.
   *
   * @param {string} name The name to reference the research by.
   *
   * @returns {boolean} Whether or not the research is known by the Researcher.
   */
  hasResearch(name) {
    return Object.keys(this.getAvailableResearches()).filter(function (research) {
      return research === name;
    }).length > 0;
  }

  /**
   * Check whether the helper is known by the Researcher.
   *
   * @param {string} name The name to reference the helper by.
   *
   * @returns {boolean} Whether or not the helper is known by the Researcher.
   */
  hasHelper(name) {
    return Object.keys(this.getAvailableHelpers()).filter(function (helper) {
      return helper === name;
    }).length > 0;
  }

  /**
   * Check whether the config is known by the Researcher.
   *
   * @param {string} name The name to reference the config by.
   *
   * @returns {boolean} Whether or not the config is known by the Researcher.
   */
  hasConfig(name) {
    return Object.keys(this.getAvailableConfig()).filter(function (config) {
      return config === name;
    }).length > 0;
  }

  /**
   * Check whether the research data is known by the Researcher.
   *
   * @param {string} name The name to reference the research data by.
   *
   * @returns {boolean} Whether or not the research data is known by the Researcher.
   */
  hasResearchData(name) {
    return Object.keys(this.getAvailableResearchData()).filter(function (data) {
      return data === name;
    }).length > 0;
  }

  /**
   * Return all available researches.
   *
   * @returns {Object} An object containing all available researches.
   */
  getAvailableResearches() {
    return (0, _lodash.merge)(this.defaultResearches, this.customResearches);
  }

  /**
   * Return all available helpers.
   *
   * @returns {Object} An object containing all available helpers.
   */
  getAvailableHelpers() {
    return this.helpers;
  }

  /**
   * Return all available configuration.
   *
   * @returns {Object} An object containing all available configuration.
   */
  getAvailableConfig() {
    return this.config;
  }

  /**
   * Return all available research data.
   *
   * @returns {Object} An object containing all available research data.
   */
  getAvailableResearchData() {
    return this._data;
  }

  /**
   * Return the Research by name.
   *
   * @param {string} name The name to reference the research by.
   *
   * @returns {*} Returns the result of the research or false if research does not exist.
   *
   * @throws {MissingArgument} Research name cannot be empty.
   */
  getResearch(name) {
    if ((0, _lodash.isUndefined)(name) || (0, _lodash.isEmpty)(name)) {
      throw new _missingArgument.default("Research name cannot be empty");
    }
    if (!this.hasResearch(name)) {
      return false;
    }
    return this.getAvailableResearches()[name](this.paper, this);
  }

  /**
   * Return the research data from a research data provider by research name.
   *
   * @param {string} research The identifier of the research.
   *
   * @returns {*} The data provided by the provider, false if the data do not exist
   */
  getData(research) {
    if (this.hasResearchData(research)) {
      return this._data[research];
    }
    return false;
  }

  /**
   * Return language specific configuration by configuration name.
   *
   * @param {string} name The name of the configuration.
   *
   * @returns {*} The configuration, false if the configuration does not exist.
   */
  getConfig(name) {
    if (this.hasConfig(name)) {
      return this.config[name];
    }
    return false;
  }

  /**
   * Return language specific helper by helper name.
   *
   * @param {string} name The name of the helper.
   *
   * @returns {*} The helper, false if the helper does not exist.
   */
  getHelper(name) {
    if (this.hasHelper(name)) {
      return this.helpers[name];
    }
    return false;
  }
}
exports.default = AbstractResearcher;
//# sourceMappingURL=AbstractResearcher.js.map